# JavaScript

## 목차

- [1. 자바스크립트 소개](#1----------)
  - [자바스크립트 개요](#---------)
- [2. 자바스크립트 기본](#2----------)
  - [script 태그](#script---)
  - [코드 구조](#-----)
  - [주석](#--)
  - [변수](#--)
  - [상수](#--)
  - [자료형](#---)
  - [자료형 - 숫자형](#---------)
  - [자료형 - 문자형](#---------)
  - [자료형 - 불린형](#---------)
  - [null](#null)
  - [undefined](#undefined)
  - [객체와 심볼](#------)
  - [typeof 연산자](#typeof----)
  - [alert](#alert)
  - [prompt](#prompt)
  - [confirm](#confirm)
  - [자료형 형변환](#-------)
  - [수학 연산자](#------)
  - [비트 연산자](#------)
  - [비교 연산자](#------)
  - [if문](#if-)
  - [삼항 연산자](#------)
  - [논리 연산자](#------)
  - [nullish 병합 연산자](#nullish-------)
  - [while문](#while-)
  - [do while문](#do-while-)
  - [for문](#for-)
  - [break와 continue](#break--continue)
  - [switch문](#switch-)
  - [함수](#--)
  - [함수 표현식](#------)
  - [콜백 함수](#-----)
  - [화살표 함수](#------)
  - [객체](#--)
  - [객체 복사](#-----)
  - [메소드와 this](#-----this)
  - [생성자 함수](#------)
  - [원시값의 메소드](#--------)
  - [숫자형](#---)
  - [문자형](#---)
  - [배열](#--)
  - [배열과 메소드](#-------)
  - [iterable 객체](#iterable---)
  - [맵](#-)
  - [셋](#-)
  - [구조 분해 할당](#--------)
  - [JSON과 메소드](#json-----)
  - [나머지 매개변수](#--------)
  - [try catch finally](#try-catch-finally)
  - [에러 객체](#-----)
  - [프라미스](#----)
  - [async await](#async-await)
  - [모듈](#--)

---

## 1. 자바스크립트 소개

### 자바스크립트 개요

- **웹페이지에 생동감을 불어넣기 위해 만들어진** 프로그래밍 언어이다.
- 브라우저에서 쓸 목적으로 고안되었으나, 현재는 다양한 환경에서 사용된다.
- 브라우저 내 동작 시 기능
  - HTML 요소를 추가, 수정하거나 스타일을 수정할 수 있다.
  - 마우스 클릭, 포인터 움직임 등 사용자 행동에 반응할 수 있다.
  - 네트워크를 통해 서버에 요청을 보낼 수 있다.
  - 쿠키에 접근하여 설정할 수 있다.
  - 로컬 스토리지를 이용하여 클라이언트 측에 데이터를 저장할 수 있다.
- 브라우저 내 할 수 없는 기능
  - 운영체제가 지원하는 기능을 브라우저가 직접 사용하지 못하게 되어 있기 때문에, 디스크에 저장된 파일에 접근 시 제약을 받을 수 있다.
  - 사용자가 브라우저 창에 파일을 드래그하거나, `<input>` 태그를 통해 파일을 선택할 때와 같이 예외적인 상황에만 파일 접근이 가능하다.
  - 카메라나 마이크와 같이 디바이스 기능을 이용하기 위해 사용자의 명시적 허가가 필요하다.
  - 개인정보 보호를 위해 **동일 출처 정책(Same Origin Policy)**이 적용된다.
    - **동일 출처 정책(SOP)** : 어떤 출처에서 불러온 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호 작용하는 것을 제한하는 보안 정책. URL의 프로토콜, 포트, 호스트가 같아야 동일한 출처라 한다.
  - 보안 상의 이유로 교차 출처 **리소스 공유(Cross Origin Resource Sharing)**가 적용된다.
    - **교차 출처 리소스 공유(CORS)** : 페이지를 생성한 서버와는 정보를 쉽게 주고받을 수 있지만, 타 서버와 통신하기 위해서는 서버 측에서 승인을 해야 한다는 내용의 정책.

## 2. 자바스크립트 기본

### script 태그

- `<script>` 태그를 통해 HTML 파일(\*. html)에 자바스크립트를 작성할 수 있다.
- 브라우저는 `<script>` 태그를 만나면 자동으로 처리한다.
- 속성
  - `<script src="js파일경로">`
    - 자바스크립트 파일(\*.js)에 따로 작성한 스크립트를 `src` 속성을 통해 불러올 수 있다.
    - `src` 속성이 사용된 경우, 태그 내 코드는 실행되지 않는다.

### 코드 구조

- 가독성을 위해 명령어 단위로 줄을 구분하여 작성한다.
- 줄바꿈이 있으면 세미콜론을 생략해도 암시적으로 세미콜론이 있는 것으로 해석한다.
- 단, 예외적인 경우가 있기 때문에 **세미콜론을 명시**하는 것이 좋다.
  - 예외적인 경우로, 연산자를 끝으로 줄바꿈이 일어나는 경우가 있다.

### 주석

- 한 줄 주석은 `//` 뒤에 작성할 수 있다.
- 여러 줄 주석은 `/*` 와 `*/` 사이에 작성할 수 있다.
- `Ctrl + /` 를 통해 해당 줄을 `//` 주석 처리할 수 있다.
- `Ctrl + Shift + /` 를 통해 해당 줄을 `/**/`주석 처리할 수 있다.
- `/*` 와 `*/` 사이에 `/**/` 가 있으면 에러가 발생한다.

### 변수

- `let` 키워드를 통해 변수를 생성한다.
- 변수명을 통해 변수에 접근할 수 있다.
- 한 변수를 다른 변수에 복사할 수 있다.
- 같은 변수를 여러 번 선언하면 에러가 발생한다.
- 변수명은 문자와 숫자, `$`, `_` 로만 정의할 수 있으며, 첫 글자는 숫자가 될 수 없다.
- 변수명은 대소문자를 구분한다.
- 예약어(이미 자바스크립트 내부에서 사용 중인 키워드)는 변수명으로 사용할 수 없다.
- 자바스크립트에서는 관습적으로 **낙타 표기법(camelCase)**를 사용한다.
- 변수명을 통해 변수에 어떤 것이 담겨있는지 알 수 있게 해야 한다.

  ```jsx
  let firstVariable = "hello world";
  let secondVariable;

  secondVariable = "nice to meet you";
  firstVariable = secondVariable;

  console.log(test1); // nice to meet you 출력
  ```

### 상수

- `const` 키워드를 통해 변수를 생성한다.
- 상수는 값을 변경할 수 없으며, 변경 시도 시 에러가 발생한다.
- 기억하기 힘든 값을 상수로 저장하여 활용할 수도 있다.
  - 기억하기 힘든 값은 대표적으로 16진수 컬러 코드가 있다.
- 하드 코딩한 값을 상수에 저장할 때, 상수명을 대문자로 하는 것이 관습이다.

```jsx
const COLOR_RED = "#FF0000";

console.log(COLOR_RED); // #FF0000 출력
COLOR_RED = "#00FF00"; // 에러 발생
```

### 자료형

- 자바스크립트는 자료의 타입은 있지만 변수에 저장되는 값의 타입은 언제든지 바뀔 수 있는 동적 언어이다.

### 자료형 - 숫자형

- 숫자형은 정수와 부동소수점 숫자를 나타낸다.
- `+`, `-`, `*`, `/`가 대표적인 연산자이다.
- `Infinity`, `-Infinity`, `NaN`같은 값도 숫자형에 포함된다.
  - `Infinity`
    - 어떤 숫자보다 더 큰 값, 무한대(∞)이다. 어떤 숫자를 0으로 나누거나 직접 키워드를 입력하여 접근할 수 있다.
  - `NaN`
    - 계산 중 에러가 발생했음을 알려주는 값이다. 부정확하거나 정의되지 않은 수학 연산 사용 시 반환된다.
    - `NaN`에 어떠한 추가 연산을 해도 `NaN`이다.
- 내부 표현 방식 때문에 자바스크립트는 `(2^53)-1`보다 큰 값과  `-((2^53)-1)`보다 작은 값은 숫자형으로 나타낼 수 없다. 이 경우, `BigInt형` 을 사용하여 나타낼 수 있다.
  - `BigInt형`
    - 길이에 상관없이 정수를 나타낼 수 있다.
    - 정수 오른쪽 끝에 `n`을 붙여 만들 수 있다.

### 자료형 - 문자형

- 문자열은 따옴표로 묶은 값을 나타낸다.
- 큰따옴표, 작은따옴표, 역따옴표(백틱) 어느 것을 사용해도 무방하나, 쌍은 맞춰 주야 한다.
- **백틱**으로 변수나 연산식을 감싼 후 `${...}`안에 넣어주면, 문자열 내 원하는 변수나 값을 얻을 수 있다.

### 자료형 - 불린형

- 불린형은 `true` 혹은 `false` 값을 나타내는 자료형이다.
- 긍정 혹은 부정을 나타내는 값을 저장할 때 사용한다.

### null

- 어느 자료형에 포함되지 않으며, `null`자체가 `null`값만 포함하는 자료형이다.
- 존재하지 않는 값(nothing), 비어 있는 값(empty), 알 수 없는 값(unknown)을 나타낼 때 사용한다.
- 명시적으로 할당 가능하다.

### undefined

- 어느 자료형에 포함되지 않으며, `undefined`자체가 `undefined`값만 포함하는 자료형이다.
- 값이 할당되지 않은 상태를 나타낼 때 사용한다.
- 명시적으로 할당 가능하나, 권장하지 않는다.

### 객체와 심볼

- 객체(object)형은 복잡한 개체를 표현할 수 있다.
- 심볼(symbol)은 객체의 고유한 식별자를 만들 때 사용한다.
- 자세한 내용은 추후 설명한다.

### typeof 연산자

- `typeof` 연산자는 인수의 자료형을 반환한다.

```jsx
typeof 0; // number 출력
typeof true; // boolean 출력
typeof alert; // function 출력(함수가 피연산자면 function을 반환. 하지만 함수는 객체형이다.)
```

### alert

- `확인` 버튼을 누를 때까지 메시지를 보여주는 창을 띄운다.
- 인자로 보여줄 메시지를 전달한다.

```jsx
alert("Hello Wolrd");
```

### prompt

- `메시지`와 `입력 필드`, `확인`, `취소` 버튼이 있는 창을 띄운다.
- 첫 번째 인자에 보여줄 메시지, 두 번째 인자는 입력 필드의 초기 값으로 선택 가능하다.

```jsx
prompt("보여줄 메시지", ["입력 필드 초기값"]);
```

### confirm

- `메시지`와 `확인`, `취소` 버튼이 있는 창을 띄운다.
- 인자로 보여줄 메시지를 전달한다.
- `확인`을 누를 시 `true`, `취소`를 누를 시 `false`를 반환한다.

```jsx
confirm("Can you speak English?");
```

### 자료형 형변환

- `String()`의 인자로 값을 전달하여 문자형으로 형변환한다.
- `Number()`의 인자로 값을 전달하여 숫자형으로 형변환한다. 이때, 숫자 이외의 값이 들어있는 경우 `NaN`을 출력한다. 숫자와 관련된 함수와 표현식에서도 자동으로 형변환이 일어난다.
- `Boolean()`의 인자로 값을 전달하여 불린형으로 형변환한다. `숫자 0`, 빈 문자열, `null`, `undefined`, `NaN`같이 직관적으로 비어있다고 느껴지는 값은 `false`가 되며, 이외 값은 `true`가 된다.
  - `문자열 0`은 `true`를 반환한다.

### 수학 연산자

- 수학 연산자는 다음과 같다.
  - 덧셈 연산자 `+`, 뺄셈 연산자 `-`, 곱셈 연산자 `*`, 나눗셈 연산자 `/`, 나머지 연산자 `%`, 거듭제곱 연산자 `**`가 있다.
- 이항 연산자로써 `+`로 두 문자열을 연결할 수 있다. 숫자와 문자열을 `+`로 연산할 경우, 숫자가 문자형으로 변환된다.
- 단항 연산자로써 `+`는 숫자가 아닌 값을 숫자형으로 형변환한다.
- 할당 연산자 `=`는 산술 연산자 혹은 비트 연산자와 합쳐서 `+=`, `*=`등 의 형태로 사용할 수 있다.
- 증가 연산자 `++`는 값을 1 증가시키며, 감소 연산자 `--`는 값을 1 감소시킨다.
-

### 비트 연산자

- 비트 연산자는 다음과 같다.
  - 비트 AND 연산자 `&`, 비트 OR 연산자 `|`, 비트 XOR 연산자 `^`, 비트 NOT 연산자 `~`, 시프트 연산자 `<<`, `>>` 가 있다.

### 비교 연산자

- 비교 연산자로써 `>`, `>=`, `<`, `<=`, `==`, `!=`가 있다. 참이면 `true`, 거짓이면 `false`를 반환한다.
- 문자열 비교 시 **사전순**으로 비교한다. 문자열이 다른 한 문자열을 포함하는 경우, 긴 문자열이 더 큰 것으로 판단한다.
- 비교하려는 값들의 자료형이 다르면 값을 숫자형으로 변환하여 비교한다.
- `===`는 일치 연산자로서, 자료형 일치 여부까지 검사한다.
- `null`과 `undefined`는 비교 연산자 사용 시 반환 값이 까다롭기 때문에, 주의한다.

### if문

- `if(...){...}`문은 `(...)`괄호에 있는 값이 `true`인 경우 `{...}`괄호 안에 있는 코드를 실행한다.
- `if`문 뒤에 `else if(...){...}`문을 추가하여 조건 여러 개를 처리할 수 있다.
- `if`문 혹은 `else if`문 뒤에 `else{...}`문을 마지막에 추가하여 앞에서 처리하지 않은 경우에 실행하는 코드를 작성할 수 있다.

### 삼항 연산자

- `?` 앞에 있는 조건식이 `true`이면 `:`기준 앞에 있는 값이 반환되며, `false`인 경우 뒤에 있는 값이 반환된다.

```jsx
alert(5 >= 3 ? 6 : 4); // 5 출력
```

### 논리 연산자

- 논리 연산자는 다음과 같다.
  - 논리 AND 연산자 `&&`, 논리 OR 연산자 `||`, 논리 NOT 연산자 `!`가 있다.
  - `&&`는 왼쪽 피연산자부터 불린값으로 변경하여 값을 판단한 다음, 첫 번째 `falsy`값의 원래 값을 반환한다. `falsy`값이 없는 경우 마지막 피연산자를 반환한다.
  - `||`는 왼쪽 피연산자부터 불린값으로 변경하여 값을 판단한 다음, 첫 번째 `truthy`값의 원래 값을 반환한다. `truthy`값이 없는 경우 마지막 피연산자를 반환한다.
  -

### nullish 병합 연산자

- `a ?? b`에서 `a`가 `null` 혹은 `undefined`이 아닌 경우 경우 `a`를 반환하며, 그 외의 경우에는 `b`를 반환 한다.

### while문

- `while(...){...}`문은 `(...)`괄호에 있는 값이 `true`인 경우 `{...}`괄호 안에 있는 코드를 실행한다. 코드 실행 후 다시 `(...)`괄호에 있는 값을 검사하며 값이 `false`가 나올 때 까지 반복한다.

### do while문

- `do{...}while(...)`문은 `{...}`문 안에 있는 코드를 한 번 실행 후, `(...)`괄호에 있는 값에 따라 `while`문과 동일하게 동작한다.

### for문

- `for(초기식; 조건식; 증감식){...}`문에서 `초기식`은 `for`문 진입 시 최초 1회 실행되고, 이후 `조건식`이 `true`인 경우 `{...}`괄호 안에 있는 코드를 실행하고, `증감식`을 실행한다. `조건식`이 `true`인 동안 계속 코드가 실행된다.
- `증감식`에는 증가하거나 감소하는 식이 아닌 어떠한 식이 와도 상관없다.

### break와 continue

- `break`는 반복문을 종료시킨다.
- `continue`는 반복문의 현재 루프를 종료하고 다음 루프로 이동한다.
- 삼항연산자 `?` 오른쪽에는 `break`와 `continue`가 올 수 없다.
- 반복문 `for`이나 `while`앞에 `반복문별칭:` 을 작성할 수 있는데, 이때 반복문 안에서 `break 반복문별칭`을 작성하면 깊이 상관없이 해당하는 반복문까지 탈출할 수 있다.

### switch문

- 여러 개의 조건에 대하여 값을 처리할 수 있다.
- `switch(…)`안의 값이 `{…}`안에 있는 각 `case`중 `case`와 `:` 사이에 있는 값과 같은 경우 해당 코드를 실행한다.
- `case`에 해당하는 코드가 실행될 때, `break`로 코드를 마무리 하지 않으면, 아래 `case`에 있는 코드와 `default`코드까지 실행하게 된다.
- `default`는 위 케이스에 해당하지 않을 경우 실행하는 경우이다.
- 아래는 `switch`문 예시이다.

```jsx
switch(x) {
// x가 1인 경우 실행
  case 1:
    ...
    [break]

// case 여러 개를 묶을 수도 있다.
  case 2:
	case 3:
    ...
    [break]

  default:
    ...
    [break]
}
```

### 함수

- `function 변수명(전달할 파라미터, ...) { 실행할 코드 }`를 통해 함수를 정의할 수 있다. 이 방식을 `함수 선언 방식`으로 함수를 생성한다고 한다.
- 함수명은 **동사를 접두어로 함수가 어떤 동작을 하는지** 알 수 있도록 작성하는 것이 좋다.
- 함수는 간결하고 한 가지 기능만 수행할 수 있도록 정의하는 것이 좋다.
- 파라미터는 필요 시 선택적으로 정의하여 전달할 수 있다.
- 정의한 함수는 `변수명(전달할 파라미터)`를 통해 실행할 수 있다.
- 함수 내에서 변수를 선언할 수 있는데, 이를 `지역 변수`라 하며, 이는 함수 내에서만 사용 가능한 변수이다.
- `return 반환값`키워드를 통해 함수를 호출할 곳에 값을 반환할 수 있다. 단, `return 반환값`이 여러 줄인 경우 `반환값`을 `()`로 감싸서 작성한다.
- 정의 형식은 아래와 같다.

```jsx
function testMethod(parameter1, parameter2, ...) {
	let testVariable = "Hello Wolrd";
	// 함수에서 실행할 코드
  // ...

	[return 반환값]
}
```

### 함수 표현식

- 함수를 정의하는 동시에 함수 자체를 변수에 값을 할당하는 것처럼 할 수 있다. 이를 `함수 표현식`이라 한다.
- 정의 형식은 아래와 같다.

```jsx
let testMethod = function(parameter1, parameter2, ...) {
  let testVariable = "Hello Wolrd";
	// 함수에서 실행할 코드
  // ...

	[return 반환값]
};
```

### 콜백 함수

- 함수 자체를 함수의 인자로 전달하고, 필요 시 인수로 전달한 함수를 나중에 호출하는 것을 `콜백 함수`라고 한다.

### 화살표 함수

- 함수 표현식에서 `function`키워드가 아닌 `화살표 함수`방식을 통해 함수를 간결하게 정의할 수 있다.
- 인자가 하나일 경우 `()`를 생략 할 수 있으며, 함수에서 실행할 코드가 한 줄 밖에 없다면, `{}`와 `return`키워드를 생략할 수 있다.
- 정의 형식은 아래와 같다.

```jsx
let testMethod = (parameter1, parameter2, ...) => {
	// 실행할 코드
  // ...

  [return 반환값]
};
```

### 객체

- 객체는 중괄호 `{}`를 통해 생성할 수 있다. 괄호 안에는 `key : value`쌍으로 구성된 여러 개의 쌍을 넣을 수 있다.
- 프로퍼티에서 `key`는 문자형, `value`는 모든 자료형이 허용된다. 단, `key`값에 예약어가 올 수 없다.
- `객체명[key]`를 통해 `key`에 대응하는 `value`값에 접근할 수 있다.
- `객체명.key`를 통해 `key`에 대응하는 `value`값에 접근할 수 있다. 이 경우, `key`에 공백과 `$`, `_`를 제외한 문자가 있으면 에러가 발생하므로 이 경우 대괄호 `[]`를 통해 접근한다.
- 존재하지 않는 프로퍼티 접근 시 `undefined`를 반환한다.
- `key값 in 객체명`을 통해 해당 프로퍼티가 객체에 존재하는 지 진리형으로 반환받을 수 있다.
- 접근한 프로퍼티는 할당 연산자 `=`를 통해 `value`를 할당할 수 있고, `delete 객체명[key]` 혹은 `delete 객체명.key`으로 프로퍼티를 제거할 수 있다.
- 객체의 `key`값을 변수를 통해 동적으로도 선언할 수 있는데, `[변수명]`처럼 대괄호 `[]`로 감싸면 된다.
- `key`값과 `value`값이 같은 경우 `key : value`이 아닌, 하나의 값만 작성하여 프로퍼티를 선언할 수 있다.
- 아래와 같이 `for (변수명 in 객체명) {...}` 사용 시 `변수명`에 `key`값을 할당하고 순회하며 `{…}`코드를 실행할 수 있다.

```jsx
for (let keyVariable in testObject) {
  // 실행할 코드
  // ...
}
```

- 각 프로퍼티는 정수 프로퍼티인 경우, 오름차순으로 정렬 된다. 나머지 프로퍼티는 작성 순으로 나열된다.
  - 정수 프로퍼티 :
    정수로 변경했다가 다시 원래 자료형으로 변경 했을 때도 그대로인 프로퍼티
    EX : **‘43’** ( O ), **‘+43’** ( X ), **‘4.3’** ( X ),

### 객체 복사

- 객체는 변수에 저장될 때 객체 자체가 아닌, 객체를 참조할 수 있는 참조값이 저장된다.
- 따라서 단순히 할당 연산자 `=`를 통해 객체를 할당한다고 해도, 두 변수가 같은 객체를 가리키게 된다. 이를 `얕은 복사`라고 한다.
- 같은 참조가 아닌, 완전히 새로운 객체를 복사하고 싶으면, 별도의 함수를 사용하거나 반복문을 사용하여 복사할 수 있다. 이를 `깊은 복사`라 한다.

### 메소드와 this

- 객체의 프로퍼티 `value`값으로 함수가 올 수 있다. 객체의 프로퍼티인 함수를 **메소드**라 한다.
- `this` 키워드는 메소드를 호출할 때 사용한 객체를 의미한다.
- `this`가 가리키는 객체는 런타임 시 결정된다.
- 화살표 함수는 일반 함수와 달리 `this`를 가지지 않는다. 화살표 함수 내에서 `this` 사용 시 외부 함수에서 `this`값을 가져온다.

### 생성자 함수

- 생성자 함수는 일반 함수와 기술적 차이는 없으나, 두 가지 관례를 따른다.
  1. 함수명의 첫 글자는 대문자로 한다.
  2. `new` 키워드를 붙여 함수를 실행한다.
- `new` 키워드 사용 시 동작하는 것은 아래와 같다.
  1. 빈 객체를 만들어 `this`에 할당한다.
  2. `new` 키워드 뒤에 작성한 생성자 함수를 실행한다.
  3. 생성자 함수가 실행되면서 `this`에 프로퍼티 혹은 메소드가 추가된다.
  4. 생성자 함수가 프로퍼티 혹은 메소드가 추가된 `this`를 반환한다.
- 즉, `new` 키워드를 통해 생성자 함수를 실행하면, 생성자 함수에서 추가한 프로퍼티 혹은 메소드를 가진 객체가 생성된다.
- **재사용할 수 있는 객체 생성 코드**를 구현하는 데 의의가 있다.
- 생성자 함수에 `return`이 있을 때, `return` 값이 객체면 `this` 대신 객체를 반환하며, 원시값이면 `return` 문이 무시된다.

### 원시값의 메소드

- 원시값은 객체가 아니며, 원시형의 종류는 `string`, `number`, `bigint`, `boolean`, `symbol`, `null`, `undefined` 형으로 총 7가지이다.
- 객체는 프로퍼티에 다양한 종류의 값을 저장할 수 있다. `{}`를 통해 만들 수 있다.
- 원시값이 메소드나 프로퍼티에 접근하면, 추가 기능을 제공해주는 `래퍼 객체`(object wrapper)를 임시적으로 만들어준다.
- 래퍼 객체는 원시 자료형의 이름을 그대로 차용해 `String`, `Number`, `Boolean`, `Symbol`라고 부른다.

  ```jsx
  let str = "Hello";

  // String 래퍼 객체가 임시적으로 생성되어
  // 원시값이 toUpperCase()에 접근한다.
  alert(str.toUpperCase()); // HELLO 출력
  ```

- 래퍼 객체마다 제공하는 메서드가 다르다.
- 래퍼 객체가 제공하는 메서드는 원시형 프로퍼티에 참조할 때 사용할 수 있다.

### 숫자형

- 10의 N 제곱을 eN으로 나타낼 수 있다. (N은 정수)
- 숫자 앞에 `0x`를 붙이면 **16진수**, `0b`를 붙이면 **2진수**, `0o`를 붙이면 **8진수**를 나타낼 수 있다.
- `변수명.toString(사용할 진법)`은 사용할 진법에 맞게 변수에 있는 값을 변환해서 반환한다. 만약 변수가 아닌 **리터럴**로 직접 메소드를 사용하고 싶으면 `리터럴..toString(사용할 진법)`혹은 `(리터럴).toString(사용할 진법)`으로 접근한다.
- 내장 함수로 \*\*\*\*`Math.floor()`, `Math.ceil()`, `Math.round()`, `Math.trunc()`는 각각 소수 첫째 자리에서 버림, 올림, 반올림, 소수부 무시 기능을 가지고 있다. 전달인자로 숫자값을 가진 변수명을 전달하여 사용할 수 있다.
- `.toFixed(소수 자리수)`는 전달한 소수 **자리수에 맞게 소수를 반올림**한다. 소수부 길이가 소수 자리수보다 작으면 0으로 나머지를 채운다.
  - 참고: 소수(0.3 등)는 작은 오차가 존재하는데 `.toFixed(2)`정도로 설정하면 오차를 없앨 수 있다.
- `isNaN(값)`은 값의 `NaN`여부에 따라 `boolean`타입이 반환된다. `NaN === NaN`은 `false`이므로 필요한 메소드이다.
  - 참고: `isNaN(값)`은 잘못된 수 연산 or 숫자가 아닐 때 `true`를 반환한다.
- `isFinite(값)`은 값이 `NaN`, `Infinity`, `-Infinity`이 아닌 **숫자**면 `true`를 반환, 이외에는 `false`를 반환한다. 아래와 같이 문자열이 일반 숫자인지 검증하는데 사용한다.

```jsx
let num = +prompt("숫자를 입력하세요.", "");

alert(isFinite(num)); // 일반 숫자가 아니면 false 출력
```

- `Object.is(값1, 값2)`는 값1과 값2가 같은지 boolean형으로 반환한다. `Object.is(NaN, NaN)`은 `true`, `Object.is(0, -0)`은 `false`이다. 완전히 같을 때만 `true`이다.
- `parseInt(문자열)`, `parseFlaot(문자열)`은 불가능할 때까지 숫자를 읽어 읽은 숫자를 숫자형으로 반환한다. 읽을 숫자가 아예 없을 때 `NaN`을 반환한다. 두 메서드에는 두 번째 인자도 전달할 수 있는데, 읽을 때의 **진법 정보**를 전달하면 된다.
- `Math.random()`은 0 이상 1 미만의 난수를 반환한다.
- `Math.max(a, b, c,…)`는 최댓값을 반환한다.
- `Math.mix(a, b, c,…)`는 최솟값을 반환한다.
- `Math.pow(a, b)`는 a의 b제곱을 반환한다.

### 문자형

- 백틱 사용 시 문자열을 여러 줄로 나타낼 수 있다.
- 자바스크립트에는 여러가지 이스케이프 문자가 있다. 대표적으로 `\n`, `\\`, `\'`, `\"` 등이 있다.
- `문자열.length`를 통해 문자열 길이를 반환할 수 있다.
- 문자열은 대괄호 `[]`를 통해 인덱스 접근을 할 수 있다.
- `문자열.charAt(인덱스)`도 `문자열[인덱스]`와 동일한 기능을 하지만, 해당 인덱스에 요소가 없을 시 `[]`는 `undefined`를, `charAt()`은 **빈 문자열**을 반환한다.
- `for (let 변수명 of 문자열) {…}`을 통해 문자열 각 요소를 순회하며 코드를 실행할 수 있다.
- 인덱스로 문자열 요소에 접근해도 문자열은 불변 자료형이기 때문에, 변경 시도 시 에러가 발생한다. 변경이 필요할 시 새로운 문자열을 만들어 **문자열 자체에 할당**한다.
- `문자열.toUpperCase()`, `문자열.toLowerCase()`를 통해 문자열을 모두 대문자 혹은 소문자로 변경할 수 있다. `문자열[인덱스]`에 접근 시 특정 요소만 변경할 수도 있다.
- `문자열.indexOf(부분 문자열, [시작인덱스])`는 시작 인덱스부터 탐색하여 처음 탐색되는 **부분 문자열의 시작 인덱스를 반환**한다. 시작 인덱스는 생략 가능하다. 부분 문자열이 없을 시 -1을 반환한다.
- `문자열.lastIndexOf(부분 문자열, [시작인덱스])`는 뒤에서부터 부분 문자열을 탐색한다.
- `문자열.includes(부분 문자열, [시작 인덱스])`는 부분 문자열 존재여부에 따라 `true` 혹은 `false`를 반환한다.
- `문자열.startsWith(부분 문자열)`, `문자열.endsWith(부분 문자열)`은 부분 문자열로 문자열이 시작되거나 끝나는지에 따라 `true` 혹은 `false`를 반환한다.
- 부분 문자열을 추출하는 메소드로 3가지가 있다.
  - `문자열.slice(시작인덱스, [종료인덱스])`는 시작 인덱스부터 종료 인덱스 전까지의 부분 문자열을 반환한다. 종료 인덱스 생략 시 시작 인덱스부터 문자열 끝까지 반환한다. 시작 인덱스와 종료 인덱스에 `-`를 붙여 문자열 끝에서부터 진행할 수 있다.
  ```jsx
  let str = "hello";
  // 끝에서 3번째부터 끝에서 1번째까지, ll 출력
  alert(str.slice(-3, -1));
  ```
  - `문자열.substring(시작인덱스, [종료인덱스)`는 slice 메소드와 동일하나, 시작인덱스가 종료인덱스보다 커도 된다는 차이가 있다. 작은 값이 시작값이 된다.
  - `문자열.substr(시작인덱스, 추출할문자열길이)`는 시작인덱스부터 추출할 문자열 길이만큼 부분 문자열을 반환한다.

### 배열

- 빈 배열은 `new Array()` 혹은 `[]`로 만들 수 있다. 소괄호 혹은 대괄호 안에 요소를 넣어서 선언할 수 있다. 주로 `[]`를 사용한다.
- `배열명.length`는 배열 길이를 반환한다. 단, 배열 마지막 원소의 인덱스에 반응하므로 인덱스는 순차적으로 사용하는 것이 좋다. 또한, `length`값을 임의로 변경할 수 있다. 이때, 배열의 마지막 인덱스보다 작게 값을 할당하면 배열 일부가 삭제되므로 주의한다.
- `배열명.pop()`은 끝 요소를 제거하면서 반환하고,
  `배열명.push(값)`은 배열 끝에 값을 요소로 추가한다. 값은 한 번에 여러 개 추가할 수도 있다.
- `배열명.shift()`는 배열 앞 요소를 제거하면서 반환하고,
  `배열명.unshift(값)`는 배열 앞에 값을 요소로 추가한다. 값은 한 번에 여러 개 추가할 수도 있다.
- `for (let 변수명 of 배열명) {…}`을 통해 변수에 배열 요소를 할당하여 순차적으로 순회하며 코드를 수행할 수 있다.

### 배열과 메소드

- `배열명.splice(시작인덱스, 제거할요소개수, 요소값, …)`는 시작인덱스부터 제거할 요소 개수만큼 제거하고, 시작 인덱스부터 입력된 요소 값들을 배열에 입력한다. 입력된 요소
- `배열명.slice([시작인덱스], [종료인덱스])`는 시작 인덱스부터 종료 인덱스 전까지 부분 배열을 반환한다. 인자를 하나 작성하면 시작 인덱스로 인식하고, 작성하지 않으면 배열 전체를 반환한다.
- `배열명.concat(요소값, ...)`은 배열 뒷 부분에 요소값을 추가한 배열을 반환한다. 요소값이 배열인 경우, 배열의 모든 요소가 추가된다. 요소값이 객체인 경우 객체 자체를 요소로 추가한다.
- `배열명.forEach((요소, 인덱스, 현재배열) ⇒ {…})`는 주어진 함수를 배열 각 요소에 대해 실행할 수 있게 한다.
- 문자열과 마찬가지로 배열의 특정 요소를 찾고 싶은 경우 `.indexOf`, `.lastIndexOf`, `.includes` 메소드를 사용한다.
- `배열명.find((요소, 인덱스, 현재배열) ⇒ {…})`은 함수가 `true`을 반환하는 경우 탐색이 중단되며 **요소**가 반환된다. 요소를 찾지 못하면 `undefined`를 반환한다. **객체로 이루어진 배열**을 다룰 때 자주 사용된다.
- `배열명.filter((요소, 인덱스, 현재배열) ⇒ {…})`은 함수가 `true`을 반환하는 **요소 전체를 담은 배열**을 반환한다.
- `배열명.map((요소, 인덱스, 현재배열) ⇒ {…})`은 요소 전체를 대상으로 함수를 호출하고, **호출 결과를 배열**로 반환한다.
- `.find`, `.filter`, `.map` 등 대부분의 배열 메소드는 마지막 인자로 하나 더 받을 수 있는데, 이 인자는 `this`를 의미한다.
- `배열명.reverse()`은 배열을 요소를 역순으로하는 메소드이다.
- `배열명.sort()`은 배열을 **사전 오름차순으로 정렬**된다. 숫자순으로 정렬하고 싶으면 아래와 같이 함수를 인자로 전달하여 할 수 있다.

```jsx
let arr = [3, 5, 16, 9, 7, 81];
arr.sort((a, b) => a - b); // 숫자 오름차순으로 정렬
```

- `문자열.split(구분자, [배열최대길이])`는 문자열을 **구분자**를 기준으로 나누어 나누어진 것을 요소로 하는 배열을 반환한다.
  - 배열 최대 길이를 인자로 전달 시 배열은 최대 길이 이상으로 커지지 않는다.
  - 구분자를 공백으로 전달 시, **글자 단위**로 분리하여 배열을 반환한다.
- `배열명.join(구분자)`은 배열의 요소 전체를 각 요소 사이마다 구분자를 사이에 추가하여 문자열을 반환한다.

### iterable 객체

- `for … of`을 사용할 수 있는(반복 가능한) 객체를 이터러블이라 한다.
- 이터러블에는 `Symbol.iterator`가 구현되어야만 한다.

### 맵

- 맵은 `key`가 있는 데이터를 저장한다는 점에서 `객체`와 유사하나, `key`에 다양한 자료형이 올 수 있다는 것에 차이가 있다.
- 맵의 주요 메소드와 프로퍼티는 다음과 같다.
  - `new Map()`: 맵을 생성한다.
  - `map.set(key, value)`: `key`와 `value`를 맵에 저장한다.
  - `map.get(key)`: `key`에 해당하는 `value`를 반환한다. `key`가 없을 시, `undefined`를 반환한다.
  - `map.has(key)`: `key`가 존재하면 `true`, 없으면 `false`를 반환한다.
  - `map.delete(key)`: `key`에 해당하는 `value`를 삭제한다.
  - `map.clear()`: 맵의 모든 요소를 제거한다.
  - `map.size`: 맵의 요소 개수를 반환한다.
- 다음 메소드를 통해 맵의 요소에 반복 작업이 가능하다.
  - `map.keys()`: 각 요소의 `key`를 모은 이터러블 객체를 반환한다.
  - `map.values()`: 각 요소의 `value`를 모은 이터러블 객체를 반환한다.
  - `map.entries()`: 각 요소를 `[key, value]` 형태로 하는 이터러블 객체를 반환한다.
  - `맵명.forEach((value, key, 현재맵) ⇒ {…})`을 통해 맵의 각 요소를 순회하며 코드를 실행할 수 있다.

### 셋

- 셋은 **중복을 허용하지 않는 값**을 모아둔 컬렉션이다.
- 셋의 주요 메소드와 프로퍼티는 다음과 같다.
  - `new Set([이터러블])`: 셋을 생성한다. 이터러블의 값을 요소로하여 셋을 생성한다. 대부분 배열을 입력 받는다.
  - `set.add(value)`: `value`를 셋에 저장한다.
  - `set.has(value)`: `value`가 존재하면 `true`, 없으면 `false`를 반환한다.
  - `set.delete(value)`: 해당하는 `value`를 삭제한다. 삭제 성공 여부에 따라 `boolean` 값을 반환한다.
  - `set.clear()`: 셋의 모든 요소를 제거한다.
  - `set.size`: 셋의 요소 개수를 반환한다.
- 다음 메소드를 통해 셋의 요소에 반복 작업이 가능하다.
  - `set.keys()`: 각 요소의 `value`를 모은 이터러블 객체를 반환한다.
  - `set.values()`: `set.keys()`와 동일하다. 맵과 호환성을 위해 존재한다.
  - `set.entries()`: 각 요소를 `[value, value]` 형태로 하는 이터러블 객체를 반환한다.
  - `맵명.forEach((value, key, 현재맵) ⇒ {…})`을 통해 맵의 각 요소를 순회하며 코드를 실행할 수 있다.

### 구조 분해 할당

- 구조 분해 할당을 이용하여 배열과 객체를 변수로 연결할 수 있다.
- 연산자 `...`을 이용하여 나머지 부분을 연결할 수 있다.
- 적용 예시는 아래와 같다.

```jsx
let arr = [5, 7, 9, 23];
let obj = { key1: 2, key2: 4 };

let [var1, var2, ...rest] = arr;
// var1 = 5, var2 = 7, rest = [9, 23]
let { key1: var9, key2, key3 } = obj;
// var9 = 2, key2 = 4, key3 = undefined
```

### JSON과 메소드

- JSON은 값이나 객체를 나타내는 범용 포맷이다. 데이터 교환 시 주로 사용한다.
- `JSON.stringify(값)`는 객체를 JSON으로 바꿔준다. 중첩 객체 또한 같이 변경된다. 단, 순환 참조가 있으면 에러가 발생한다.
- JSON으로 변경 가능한 값은 아래와 같다.
  - 객체
  - 배열
  - 원시형:
    - 문자형
    - 숫자형
    - 불린형
    - null
- `함수 프로퍼티`, `심볼형 프로퍼티`, `값이 undefined인 프로퍼티`는 JSON으로 변경(직렬화) 시 무시된다.
- `JSON.parse(JSON, [리시버])`은 JSON을 객체로 바꿔준다.

  - `리시버`는 `key:value`형식으로 오는 JSON 요소에 적용되는 함수이다.
  - 아래는 문자열로 인식되는 값을 Date형식으로 변경하고 싶을 때 `리시버`를 사용한 예시이다.

  ```jsx
  let json = '{"title":"Hello","date":"2023-01-22T12:00:00.000Z"}';

  let meetup = JSON.parse(json, (key, value) => {
    if (key == "date") {
      // JSON 요소의 key값이 date이면, Date 타입으로 value을 반환한다.
      return new Date(value);
    }
    return value;
  });
  ```

### 나머지 매개변수

- 연산자 `...`는 **나머지 매개변수**나 **스프레드 문법**으로 사용 가능하다.
  - 인수 개수 제한이 없는 함수를 정의할 때 나머지 매개변수를 사용한다.
  - 다수의 인수를 받는 함수에 배열 전달 시 스프레드 문법을 사용한다.
- 나머지 매개변수로 사용 시 마지막 인자로 사용해야 한다.
- 스프레드 문법으로 배열을 합칠 수 도 있다.

### try catch finally

- `try catch`문은 에러 발생 시 스크립트 중단을 방지하고, 에러 발생 시 실행할 코드를 작성할 수 있게 한다.
- 동작 알고리즘은 아래와 같다.
  1. `try {…}`코드가 실행된다.
  2. 에러가 없으면, `catch(err) {...}`문은 건너뛴다.
  3. 에러가 있으면, `try {...}` 코드 실행이 중단되고, `catch(err) {…}`문의 코드가 실행된다.
  4. 에러 발생 여부와 관계없이 `finally`문의 코드는 항상 실행된다.
- 사용 예시는 아래와 같다.

```jsx
try {
  let a = 3;
  let a = 5;
  alert(a);
} catch (e) {
  alert("에러 발생");
} finally {
  alert("무조건 실행");
}
```

### 에러 객체

- 에러 객체를 `catch`문에서 인수로 받을 수 있는데, 객체명은 직접 지정할 수 있다. 에러 객체는 다음과 같은 프로퍼티를 가진다.
  - `name`: 에러명
  - `message`: 에러 내용을 담고 있는 메시지
- 에러 객체가 필요 없으면 `catch`문 사용 시 `(err)`을 생략해도 된다.
- `throw 에러객체명`을 통해 에러를 발생시킬 수 있다.
- 에러 객체는 `new Error(에러메시지)`를 통해 생성할 수 있다.
- 에러는 에러 타입 별로 처리하는 것이 디버깅에 좋다. `에러객체 instanceof 에러명`으로 발생한 에러에 따라 다르게 처리하면 된다.
  - `에러객체 instanceof 에러명`은 에러 객체의 **에러명이 명시한 것과 같으면**, `true`를 반환한다.
- 알 수 없는 에러는 `throw` 하여 `try catch`문으로 한 번 더 감싸 처리한다.

### 프라미스

- 프라미스는 비동기 처리에 사용하는 객체이다.
- `new Promise((resolve, reject) ⇒ {…})`를 통해 프라미스를 생성할 수 있다.
  - 프라미스 생성 시 `{…}`가 자동 실행된다. 이를 **실행 함수**라 한다.
  - 실행 함수 실행 후, 인수로 넘긴 콜백 함수 `resolve` 혹은 `reject`를 호출 해야 한다.
    - `resolve(value)` : 실행 함수가 성공적으로 끝나면, 실행 함수의 결과 `value`와 함께 호출
    - `reject(error)`: 에러 발생 시 에러 객체 `error`와 함께 호출
- 프라미스는 다음과 같은 내부 프로퍼티를 갖는다.
  - `state`: `pending(대기)` 상태였다가 `resolve` 호출 시 , `fufilled(이행)`, `reject` 호출 시 `rejected(거부)`로 변한다.
  - `result`: `undefined`였다가 `resolve(value)` 호출 시, `value`, `reject(error)` 호출 시 `error`로 변한다.
- 내부 프로퍼티는 `.then`, `.catch`, `.finally`메소드를 통해 접근 가능하다.
  - `프라미스명.then((result) => {...}, (error) => {...})`에서 첫 번째 인수는 프라미스 이행 시 실행되며, 두 번째 인수는 프라미스 거부 시 시행된다.
  - `프라미스명.catch(에러핸들링함수)`는 `.then(null, 에러핸들링함수)`와 동일하게 동작한다.
  - `프라미스명.finally(함수)`는 프라미스 처리 시 항상 실행되지만 이행 여부는 알 수 없다. 다음 메소드에 결과와 에러를 전달한다.
  - `.then`, `.catch`, `.finally`메소드는 프라미스가 처리되는 것을 기다린다.
- 콜백을 받는 함수를 프라미스를 반환하는 함수로 바꾸는 것을 **프라미스화**라 한다.

### async await

- `async` 키워드는 함수 선언부 앞에 올 수 있다. 키워드 사용 시 해당 함수는 프라미스를 반환하게 된다.
- `await` 키워드는 `async`가 붙은 함수에서만 사용할 수 있다. `await`가 붙은 프라미스를 만나면 해당 프라미스가 처리될 때까지 기다린다. `.then` 메소드와 같이 프라미스 이행 결과 값을 얻도록 해주는 문법이다.

### 모듈

- **모듈**이란 이미 작성한 스크립트 파일(들)을 말한다.
- 변수나 함수, 클래스 선언부 앞에 `export` 키워드를 붙이면 외부 모듈에서 해당 기능에 접근할 수 있다.
- `export default` 키워드를 사용하면 해당 모듈에는 개체가 하나 있음을 명시할 수 있다.
- `import` 키워드를 통해 외부 모듈의 기능을 가져 올 수 있다. `export`키워드로 모듈을 접근하게 했다면, 불러올 기능 목록을 `{…}`안에 작성해야 한다. `export default` 키워드를 사용했을 시, 중괄호를 생략하면 된다. 또한 원하는 대로 모듈 이름을 지정할 수 있다.

### 브라우저 환경

- 자바스크립트가 돌아가는 플랫폼을 **호스트**라 하며, 호스트가 제공하는 특정 기능들을 **호스트 환경**이라 한다.
- 브라우저 환경에서는 `window`라는 루트 객체가 존재한다.
  - 브라우저 환경은 호스트인 브라우저가 제공하는 기능이다.
  - 브라우저 창을 제어할 수 있는 메소드를 제공한다.
  - `window`는 자바스크립트 코드의 전역 객체이다.
  - `window` 하위 객체로써 `DOM`, `BOM`, `JavaScript`가 있다.
- 브라우저 객체 모델(BOM)은 문서 이외의 모든 것을 제어하기 위해 브라우저 환경에서 제공하는 추가 객체이다.
  - `screen`, `location`, `history`, `navigator` 객체 등이 있다.

### 문서 객체 모델(DOM)

- **DOM**은 웹 페이지 내의 모든 콘텐츠를 **객체**로 나타낸다. 이 객체는 수정이 가능하다.
- `document` 객체를 통해 페이지 내의 모든 것을 변경할 수 있고, 원하는 것을 만들 수 있다.
  - 아래 링크에서 `document`의 프로퍼티와 메소드 정보 등 DOM 조작 관련한 정보를 얻을 수 있다.
  [DOM](https://dom.spec.whatwg.org/)
  - 아래 링크에서는 CSS 규칙과 스타일 시트를 객체로 다루는 방법에 대한 정보를 얻을 수 있다.
  [](https://www.w3.org/TR/cssom-1/)

### DOM 트리

- DOM에 따르면, 모든 **HTML 태그는 객체**이다. 태그 내 문자 역시 객체이다.
- `document` 객체를 통해 DOM 즉, HTML 태그와 태그 내 문자를 조작할 수 있다.
  - **태그**는 DOM에서 **요소 노드(노드)**라 부른다. `<html>`은 루트 노드가 된다.
  - **태그 내 문자**는 DOM에서 **텍스트 노드**라 부른다. 텍스트 노드는 문자열만 담을 수 있으며, 자식 노드를 가질 수 없다.
  - 주석도 DOM에서 주석 노드라 부른다.
- 개발자 도구(**F12**)에서 노드 선택 후, **ESC**키를 누르면 콘솔을 통해 직접 노드를 제어할 수 있다.
  이때, `$0`는 마지막 선택 노드, `$1`는 그 이전 선택 노드를 접근하게 한다. - 이외의 개발자 도구 기능은 아래 링크를 참고한다. 크롬 개발자 도구 문서 사이트이다.
      [Chrome DevTools - Chrome Developers](https://developer.chrome.com/docs/devtools/)

### DOM 탐색

- `document` 객체가 제공하는 노드 접근을 위한 기본 프로퍼티는 아래와 같다.
  - `document` 객체가 제공하는 아래의 프로퍼티를 통해 **트리 상단의 노드**에 접근할 수 있다.
    - `document.documentElement`는 `<html>`노드를 의미한다.
    - `document.body`는 `<body>`노드를 의미한다.
    - `document.head`는 `<head>`노드를 의미한다.
  - `document`객체가 제공하는 아래의 프로퍼티를 통해 **모든 노드**에 접근할 수 있다.
    - `노드.hasChildNodes()`는 자식 노드 유무를 검사한다.
    - `노드.childNodes`는 자식 노드를 의미한다.
    - `노드.firstChild`는 첫 번째 노드를 의미한다.
    - `노드.lastChild`는 마지막 자식 노드를 의미한다.
    - `노드.parentNode`는 부모 노드를 의미한다.
    - `노드.previousSibling`는 이전 형제 노드를 의미한다.
    - `노드.nextSibling`는 다음 형제 노드를 의미한다.
  - `document`객체가 제공하는 아래의 프로퍼티를 통해 **요소 노드**에 접근할 수 있다.
    - 접근하고자 하는 노드가 요소 노드가 아니면, `null`을 반환한다.
    - `노드.children`는 자식 노드를 의미한다.
    - `노드.firstElementChild`는 첫 번째 노드를 의미한다.
    - `노드.lastElementChild`는 마지막 자식 노드를 의미한다.
    - `노드.parentElement`는 부모 노드를 의미한다.
    - `노드.previousElementSibling`는 이전 형제 노드를 의미한다.
    - `노드.nextElementSibling`는 다음 형제 노드를 의미한다.
- `document`의 기본 프로퍼티 외에도 편의를 위해 `<table>` 노드 등에도 프로퍼티가 존재한다.

### getElement* querySelector*

- `document.getElementById(노드id)`를 통해 `노드id`에 해당하는 노드에 접근할 수 있다.
- `노드.getElementsByTagName(태그명)`는 자식 노드 중 `태그명`에 해당하는 모든 노드에 접근할 수 있다.
- `노드.getElementsByClassName(클래스명)`는 자식 노드 중 `클래스명`에 해당하는 모든 노드에 접근할 수 있다.
- `노드.querySelectorAll(css선택자)`는 자식 노드 중 `css선택자`에 대응하는 모든 노드에 접근할 수 있다.
- `노드.querySelector(css선택자)`는 자식 노드 중 `css선택자`에 대응하는 노드 중 첫 번째 노드에 접근할 수 있다.
- 노드 자리에 `document`가 들어가면 문서 전체를 대상으로 한다.
